## Journey-Driven Agility

We practice agile software development every day. Fundamentally, we need an approach to generating feedback rapidly and iteratively, repeating these essential steps:

1. Pick a direction to go.
2. Take a step in that direction.
3. Evaluate progress and impact.

How might we embellish this high-level process using a journey-driven approach? Consider an ask from a client or customer. A common origin story is a request from a client to achieve a classic growth curve:

![A curved line with one arrowhead showing accelerating growth from right to left, bending upward towards a destination.](snowman_01_our_transformative_growth_objective.png)

Our experience tells us that to get there we need to iterate. This idea of iteration is an ancient idea of infinite rebirth is often represented as an ouroboros, or snake eating its own tail:

![A single arrowhead line wrapped around a circle, pointing back to itself; an ouroboros or snake eating itself.](snowman_02_to_get_there_we_iterate.png)

Segmenting this iteration into delivery and feedback, we've modeled our 3 point list. The lower line is the next step and the feedback line is the evaluation. The checkpoints are the release and the evaluation. Pick a direction, take a step in the direction (delivery), then evaluate progress and impact (feedback) before the next action:

![One circle made from two arrowhead arcs. The bottom solid and the top dotted. At the end of each line is a smaller circle representing a destination or checkpoint.](snowman_03_testing_and_learning_are_part_of_the_process.png)

## Engineering

It can be this simple. You can layer in a variety of detailed methods. Consider a daily loop using Scrum. The left checkpoint is the daily scrum. The right checkpoint is the daily release. The solid line is the work from the backlog to the next release. The dotted line is the test feedback from the last release (returning us to the next daily scrum).

On the same Scrum team, each of these daily iterations would form a larger loop for the sprint. The left check point is the retrospective from the prior sprint. The right checkpoint is the demonstration at the end of the sprint. The dotted line is the feedback from the release and the work into the next retrospective. <!-- TODO To learn more about Scrum,  cite preferred scrum -->

On most projects there are many teams working on different parts of the project. Architectural boundaries make it possible to decompose large engineering projects into many smaller and more manageable teams. Other patterns emerge at scale with specialized teams for automation and developer experience (DevOps). <!-- TODO: link to DevOps --> 

## Design

Outside of engineering there is often a different kind of iterative loop happening on the product design teams. Feedback from launches can lead to a need to reconsider the direction of the product itself. This is often a different team entirely following a different process:

![Two circles, each made from two arrowhead arcs. Each circle has two checkpoints (though the middle checkpoint is shared).](snowman_04_sometimes_another_team_is_iterating_differently.png)

Think of the left circle as the product design process and the right circle as the engineering process. Since our book is concerned primarily with software development, we won't go into a lot of detail about this process. <!-- TODO: To learn more, cite 101 Design Methods -->

## Initiation

In our work with clients, we actually see an even earlier process that initiates this system of flywheels:

![A sideways snowman made of 3 circles, each made from two arrowhead arcs. Each circle has two checkpoints and two of the checkpoints are shared creating four total checkpoints.](snowman_05_three_teams_three_kinds_of_creation.png)

We call this diagram the sideways snowman. The circles increase in size as the initiation team tends to be small, the design team tends to be larger, and the engineering team tends to be the biggest (though none of these are to scale).

At this point, some labels may help:

![Labeled version of the prior sideways snowman with the six arcs labeled Originate, Restate, Make, Reframe, Scale, and Learn.](snowman_06_delivery_framework.png)

Note that most projects will iterate differently but the simplest path might be:

1. Originate
2. Restate
3. Make
4. Scale

You might then loop on Learn and Scale for a while before returning to Reframe. The Reframe/Make loop usually runs independent of the Scale/Learn loop. It is even possible that the outcome of Reframing a problem will so reset expectations that you return to Originate though that is infrequent enough that we don't show that as connected.

Adding in the checkpoints, we have this complete diagram:

![Labeled version of the four checkpoints along with a faded version of the prior labels for the arcs Originate, Restate, Make, Reframe, Scale, and Learn.](snowman_07_checkpoints_in_a_process.png)

<!-- 
See also:

1. Scrum
2. [Leading Lean Software Development: Results Are not the Point]()

-->
